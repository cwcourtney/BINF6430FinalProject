---
title: "scRNA-seq Workflow Exploration"
author: "Courtney Wong"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: yes
    toc_float: yes
    df_print: paged
    number_sections: true
---

```{r setup, echo=FALSE, warning=FALSE, message=FALSE}
knitr::opts_chunk$set(
	echo = TRUE
)
```

```{r lib}
suppressPackageStartupMessages({
  library(dplyr)
  library(knitr)
  library(Seurat)
  library(patchwork)
  library(ggplot2)
  library(purrr)
  library(ggpubr)
})
```

# Overview

In this exercise, we explore the bioinformatics methods used by Liao et al. (2020) to process single-cell RNA-seq data starting from raw FASTQ files. Our goal is to gain exposure to the workflow and understand key filtering steps. The subset of samples selected for interrogation (BALF-C141, BALF-C143, and C-51) were derived from bronchoalveolar immune cells taken from the lung of a patient under 3 conditions: mild COVID-19, severe COVID-19, and healthy control, respectively.

# FASTQ Processing Methods

## Obtain FASTQ files from GEO/ENA in bulk

Raw paired-read FASTQ files from this scRNA-seq experiment are available online under the GEO accession ID [GSE145926](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE145926). To obtain direct links to each of the 12 samples in bulk, we query this accession ID in [SRA explorer](https://sra-explorer.info/), select the relevant samples, then download the metadata to a csv, shown below.

```{r, echo=FALSE}
read.csv("../samples/SampleList_covid.csv", header=FALSE) %>%
  arrange(V1) %>%
  kable(col.names = c("Accession ID", "Sample Name", "FASTQ Link"))
```

We then supply this .csv as an input to our sbatch script below to download all the FASTQs locally.

```{bash, code=readLines("get_fastq.sh"), echo=TRUE, eval=FALSE}
```

We now have the following file structure under `/scratch/${USER}/data/`:

```         
.
|-- BALF-C141
|   |-- SRR11181954_1.fastq.gz
|   `-- SRR11181954_1.fastq.gz
|-- BALF-C142
|   |-- SRR11181955_1.fastq.gz
|   `-- SRR11181955_2.fastq.gz
|-- BALF-C143
|   |-- SRR11181956_1.fastq.gz
|   `-- SRR11181956_2.fastq.gz
|-- BALF-C144
|   |-- SRR11181957_1.fastq.gz
|   `-- SRR11181957_2.fastq.gz
|-- BALF-C145
|   |-- SRR11181958_1.fastq.gz
|   `-- SRR11181958_2.fastq.gz
|-- BALF-C146
|   |-- SRR11181959_1.fastq.gz
|   `-- SRR11181959_2.fastq.gz
|-- C100
|   |-- SRR11537948_1.fastq.gz
|   `-- SRR11537948_2.fastq.gz
|-- C148
|   |-- SRR11537949_1.fastq.gz
|   `-- SRR11537949_2.fastq.gz
|-- C149
|   |-- SRR11537950_1.fastq.gz
|   `-- SRR11537950_2.fastq.gz
|-- C152
|   |-- SRR11537951_1.fastq.gz
|   `-- SRR11537951_2.fastq.gz
|-- C51
|   |-- SRR11537946_1.fastq.gz
|   `-- SRR11537946_2.fastq.gz
`-- C52
    |-- SRR11537947_1.fastq.gz
    `-- SRR11537947_2.fastq.gz
```

Per the 10X Genomics Chromium Single Cell 5’ protocol, note that Read 1 is the 16nt barcode and 10nt UMI:

```         
(base) [wong.co@login-00 data]$ cd BALF-C141
(base) [wong.co@login-00 BALF-C141]$ zcat SRR11181954_S1_R1_001.fastq.gz | head
@SRR11181954.1 /1
GAACATCGTAACTGTATATTATTCTC
+
DCCC@;8C@7936;<->440.):8->
@SRR11181954.2 /1
AAGCCGCAGTGCGATGGTACACAGCG
+
B:DCDDB?CBC=<::BA6<>.@.9(A
@SRR11181954.3 /1
ACTGCTCCAGCCTGTGCCTGATGGTG
```

And Read 2 is the actual transcript:

```         
(base) [wong.co@login-00 BALF-C141]$ zcat SRR11181954_S1_R2_001.fastq.gz | head
@SRR11181954.1 /2
GTCTGGCCAGCTGGTGAACTGAATGTGAGTCACCTCTCTTCCAGTTGCTTTTTCTTTTTTATTTACAATGTTCAATTTCTGAATGATGTAAGCTGGACAT
+
BCBBB6B4BCBBBB;BBAA@CBCB:ACD@>9D95C5?BC@@A@B:CB?A6::B@?>?@@@B<;BA=BA7E3?ACB7AA@B>A@9?<CB+@C1AACC(:A>
@SRR11181954.2 /2
ATTGCGCCAGGTTTCAATTTCTATCGCCTATACTTTATTTGGGTAAATGGTTTGGCTAAGGTTGTCTGGTAGTAAGGTGGAGTGGGTTTGGGGCTAGGCT
+
<A@DDCCDCCB1@A<AD@=BBCCCAC;DCADCCCCBCDBDDDC=CACCACC6CD@BDACEC:BEAC>DB@CEBACCDDDCEE=CDC@4>CDDC(DCCD%=
@SRR11181954.3 /2
CCTTTCCTGTTCACTCTACCCTTTGACTCTAAATCTCAAAGCCAGTGTTGGGGCCCAGTGGCTCCATTCGATTGAAACATGGCCAATGATATCCAAGAGC
```

## Set up cellranger for the first time

As this is our first time using cellranger, there are a few setup steps to complete first:

1.  Download and unzip cellranger from 10X Genomics
2.  Download and unzip the 10X Genomics GRCh38 human reference dataset
3.  Ensure FASTQ files conform to [cellranger's expected format](https://www.10xgenomics.com/support/software/cell-ranger/latest/analysis/inputs/cr-specifying-fastqs): `[Sample Name]_S1_L00[Lane Number]_[Read Type]_001.fastq.gz` or `[Sample Name]_S1_[Read Type]_001.fastq.gz`

```{bash, code=readLines("setup_cellranger.sh"), echo=TRUE, eval=FALSE}
```

## Run cellranger on select samples

Next, we run cellranger in `count` mode to perform sample de-multiplexing, barcode processing, and single-cell 5’ UMI counting with human GRCh38 as the reference genome. At this stage, we are hard-coding to supply just one selected sample at a time for testing purposes but can modify the code at a later time to loop over multiple samples.

```{bash, code=readLines("run_cellranger.sh"), echo=TRUE, eval=FALSE}
```

The key outputs reside in the subfolder `outs/`, with the following file structure. The files we are primarily interested in are the summary report `web_summary.html` and the feature barcode matrix `filtered_feature_bc_matrix.h5`, which we have copied into this repository under `results/`.

```         
.
|-- analysis
|   |-- clustering
|   |-- diffexp
|   |-- pca
|   |-- tsne
|   `-- umap
|-- cloupe.cloupe
|-- filtered_feature_bc_matrix
|   |-- barcodes.tsv.gz
|   |-- features.tsv.gz
|   `-- matrix.mtx.gz
|-- filtered_feature_bc_matrix.h5
|-- metrics_summary.csv
|-- molecule_info.h5
|-- possorted_genome_bam.bam
|-- possorted_genome_bam.bam.bai
|-- raw_feature_bc_matrix
|   |-- barcodes.tsv.gz
|   |-- features.tsv.gz
|   `-- matrix.mtx.gz
|-- raw_feature_bc_matrix.h5
`-- web_summary.html
```

## Assess cellranger web summary

The web summary generated by cellranger provides some quality metrics on cells based on barcodes and UMIs detected in each cell as well as mapping quality to the reference genome.

### BALF-C141 (mild COVID)

![](../results/BALF-C141/WebSummary.png)

### BALF-C143 (severe COVID)

![](../results/BALF-C143/WebSummary.png)

### C51 (healthy)

![](../results/C51/WebSummary.png)

### Observations

The barcode rank plots all exhibit the characteristic "cliff and knee" shape of a typical sample (although BALF-C143 shows a less apparent knee shape). The steep dropoff in UMI counts per cell/barcode indicates good separation between cell-associated barcodes (abundant UMI count suggesting robust transcripts from real cells) and barcodes from blank droplets (extremely low, background-level UMI count suggesting either lack of a GEM or lack of a cell). We default to using cellranger's probabilistic model for calling cells to focus only on the good-quality cells, indicated by the blue colored portion of the curve.

We do need to be cautious about the imbalance of abundances among these samples. BALF-C141 contained far fewer cells (~6k) than BALF-C143 (~20k) and C51 (~13k). As a result, we detected far more reads per cell on average for BALF-C141 than the other two, but the UMIs thankfully corrected for this imbalance as intended, as the average UMI count per cell is roughly similar between the three samples, as are the total number of genes detected. Nevertheless, with such an imbalance in cell count, we should exercise caution during the upcoming QC steps and set thresholds for each sample independently before integrating.

Separately, we also note good sequencing quality based on the high valid barcode detection, valid UMI detection, and Q30 bases in the barcode. Mapping quality is also good, indicated by the high percentage of reads mapped to the genome.

# Post-Processing Methods using Seurat

## Load data

Below, we load the filtered .h5 gene count data generated by CellRanger and store it into a Seurat object. Note that we could have set a threshold for `min.cells` (features were detected in at least this many cells) and `min.features` (cells where at least this many features were detected), but Liao et al. (2020) did not mention deviating from the default for these parameters.

```{r}
# Initialize Seurat object with counts data
mild <- CreateSeuratObject(counts = Read10X_h5("../results/BALF-C141/filtered_feature_bc_matrix.h5"),
                           project = "mild")
severe <- CreateSeuratObject(counts = Read10X_h5("../results/BALF-C143/filtered_feature_bc_matrix.h5"),
                           project = "severe")
healthy <- CreateSeuratObject(counts = Read10X_h5("../results/C51/filtered_feature_bc_matrix.h5"),
                           project = "healthy")
covid.combined <- merge(mild, y=c(severe, healthy), add.cell.ids=c("M", "S", "H"), project="covid")
# Inspect
head(covid.combined@meta.data)
# Clear memory
rm(list=c("mild", "severe", "healthy"))
```

## QC and Cell Filtering

Next, we assess the quality of the cells based on the number of unique features/genes detected (`nFeature_RNA`, extremely low gene count suggests empty droplets or poor quality cells while extremely high gene count suggests doublets) and the percentage of reads that map to mitochondrial genes (`percent.mt`, a high percentage suggests contamination due to low-quality or dying cells). `nCount_RNA` is the total number of molecules detected in the cell.

```{r}
# Calculate percentage of genes that are mitochondrial
covid.combined[["percent.mt"]] <- PercentageFeatureSet(covid.combined, pattern = "^MT-")
head(covid.combined@meta.data)
VlnPlot(covid.combined, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
        ncol = 3, pt.size = 0.0001, alpha=0.1, group.by = "orig.ident") &
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
# Create scatterplots to view trend
FeatureScatter(covid.combined, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "orig.ident") &
  scale_color_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
FeatureScatter(covid.combined, feature1 = "nCount_RNA", feature2 = "percent.mt", group.by = "orig.ident") &
  scale_color_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
```

The total cell count and total gene count by sample is summarized in the table below:

```{r}
data.frame(Identity = c("healthy", "mild", "severe")) %>%
  mutate(
    TotalCells = map_int(Identity, ~ ncol(subset(covid.combined, subset = orig.ident == .x))),
    TotalGenes = map_int(Identity, ~ nrow(subset(covid.combined, subset = orig.ident == .x)))
  ) %>%
  kable()
```

Liao et al. (2020) filtered the cells using the following criteria: "gene number between 200 and 6000, UMI count above 1000 and mitochondrial gene percentage below 0.1." These suggested thresholds are indicated below with a dashed red line on the kernel density plots below:

```{r fig.width=5, fig.height=7}
p1 <- covid.combined@meta.data %>%
  ggplot(aes(x = nFeature_RNA, fill = orig.ident)) +
  geom_density(alpha = 0.3) +
  geom_vline(xintercept = c(200, 6000), color = "red", linetype = "dashed", linewidth = 0.5) +
  scale_x_log10() +
  labs(title = "Gene Count Per Cell (Pre-Filter)") +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
p2 <- covid.combined@meta.data %>%
  ggplot(aes(x = (nCount_RNA), fill = orig.ident)) +
  geom_density(alpha = 0.3) +
  geom_vline(xintercept = 1000, color = "red", linetype = "dashed", linewidth = 0.5) +
  scale_x_log10() +
  labs(title = "UMI Count Per Cell (Pre-Filter)") +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
p3 <- covid.combined@meta.data %>%
  ggplot(aes(x = percent.mt, fill = orig.ident)) +
  geom_density(alpha = 0.3) +
  geom_vline(xintercept = 10, color = "red", linetype = "dashed", linewidth = 0.5) +
  scale_x_log10() +
  labs(title = "Mt Gene % Per Cell (Pre-Filter)") +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
ggarrange(p1, p2, p3, ncol=1, common.legend=TRUE, legend="bottom")
```

We apply this feature below using `subset()` then re-plot the same figures.

```{r fig.width=8, fig.height=7}
covid.combined <- subset(covid.combined, subset = nFeature_RNA > 200 & nFeature_RNA < 6000 & nCount_RNA > 1000 & percent.mt < 10)
p1.f <- covid.combined@meta.data %>%
  ggplot(aes(x = nFeature_RNA, fill = orig.ident)) +
  geom_density(alpha = 0.3) +
  scale_x_log10() +
  labs(title = "Gene Count Per Cell (Post-Filter)") +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
p2.f <- covid.combined@meta.data %>%
  ggplot(aes(x = (nCount_RNA), fill = orig.ident)) +
  geom_density(alpha = 0.3) +
  scale_x_log10() +
  labs(title = "UMI Count Per Cell (Post-Filter)") +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
p3.f <- covid.combined@meta.data %>%
  ggplot(aes(x = percent.mt, fill = orig.ident)) +
  geom_density(alpha = 0.3) +
  scale_x_log10() +
  labs(title = "Mt Gene % Per Cell (Post-Filter)") +
  theme_bw() +
  theme(legend.position = "bottom") +
  scale_fill_manual(values = c("healthy" = "#00BA38", "mild" = "#619CFF", "severe" = "#F8766D"))
ggarrange(p1, p1.f, p2, p2.f, p3, p3.f, nrow=3, ncol=2, common.legend=TRUE, legend="bottom")
```

We observe from the violin plots and KD plots that the distributions of gene count, UMI count, and mitochondrial percent are vastly different between the three samples. **Thus, a significant limitation in Liao et al.'s filtering approach is that thresholds were not tailored to each sample to address significant differences in composition and were instead standardized across all samples.** For instance, mild samples (blue) exhibit a peak for high gene counts and healthy (green) samples exhibit a peak for high mitochondrial gene counts that are much further to the right than the other two groups. The upper threshold for gene count and the threshold for mitochondrial gene percent slice rather arbitrarily through these upper peaks. We should therefore keep in mind that mild samples still retain a large number of potential doublets and healthy samples still retain a large number of cells with high mitochondrial gene content (likely dead cells).

## Normalization

Liao et al. (2020) normalizes the filtered gene-barcode matrix using the LogNormalize method. The operation below performs normalization on a per-sample (layer) basis as intended.

```{r}
covid.combined <- NormalizeData(covid.combined, normalization.method = "LogNormalize")
```

## Selection of Highly Variable Genes

Liao et al. (2020) then "analyzed by principal component analysis (PCA) using the top 2,000 most variable genes." They do not mention a selection method for choosing the top variable features, so we use the default, `vst`, which standardizes feature values using the observed mean and expected variance predicted by local polynomial regression (loess) between log(variance) and log(mean).

```{r}
# map(c("healthy", "mild", "severe"), ~ {
#   
# })
covid.combined <- FindVariableFeatures(covid.combined, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
p <- VariableFeaturePlot(covid.combined) + theme(legend.position = "bottom")
LabelPoints(plot = p,
            points = head(VariableFeatures(covid.combined), 10),
            repel = TRUE)
```

## Scaling

## Dimensionality Reduction with PCA

# References

Liao, M., Liu, Y., Yuan, J. et al. Single-cell landscape of bronchoalveolar immune cells in patients with COVID-19. Nat Med 26, 842–844 (2020). <https://doi.org/10.1038/s41591-020-0901-9>
